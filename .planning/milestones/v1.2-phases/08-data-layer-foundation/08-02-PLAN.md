---
phase: 08-data-layer-foundation
plan: 02
type: tdd
wave: 2
depends_on: [08-01]
files_modified:
  - app/src/lib/report-detail-utils.ts
  - app/src/lib/report-detail-utils.test.ts
autonomous: true
requirements: [SC-3]

must_haves:
  truths:
    - "filterEntries returns all entries when all filter Sets are empty"
    - "filterEntries returns entries matching ANY selected client AND ANY selected employee AND ANY selected topic"
    - "aggregateByClient returns sorted results with id, name, totalHours, and revenue (null for non-admin entries)"
    - "aggregateByEmployee returns sorted results with id, name, totalHours, and revenue (null for non-admin entries)"
    - "aggregateByTopic returns sorted results with id (topicName), name, totalHours, and revenue (null for non-admin entries)"
    - "Written-off entries are included in totalHours but excluded from revenue aggregations"
    - "All aggregation results are sorted by totalHours descending"
  artifacts:
    - path: "app/src/lib/report-detail-utils.ts"
      provides: "filterEntries, aggregateByClient, aggregateByEmployee, aggregateByTopic"
      exports: ["filterEntries", "aggregateByClient", "aggregateByEmployee", "aggregateByTopic"]
    - path: "app/src/lib/report-detail-utils.test.ts"
      provides: "Full test coverage for all four functions"
      min_lines: 100
  key_links:
    - from: "app/src/lib/report-detail-utils.ts"
      to: "app/src/types/reports.ts"
      via: "ReportEntry type import"
      pattern: "import.*ReportEntry.*reports"
---

<objective>
Create pure utility functions for filtering and aggregating report entries, with full TDD test coverage. These functions power the Detail tab's charts and filtered views.

Purpose: The Detail tab (Phase 10) needs client-side filtering and aggregation of entries for six charts (Hours/Revenue by Client/Employee/Topic). Pure functions enable instant filtering without API calls.
Output: New lib/report-detail-utils.ts with four exported functions, colocated test file with full coverage
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-data-layer-foundation/08-CONTEXT.md
@.planning/phases/08-data-layer-foundation/08-RESEARCH.md
@.planning/phases/08-data-layer-foundation/08-01-SUMMARY.md
@app/src/types/reports.ts
</context>

<feature>
  <name>Filter and aggregation utilities for Detail tab</name>
  <files>app/src/lib/report-detail-utils.ts, app/src/lib/report-detail-utils.test.ts</files>
  <behavior>
    Four pure functions operating on ReportEntry arrays:

    1. filterEntries(entries: ReportEntry[], clientIds: Set&lt;string&gt;, employeeIds: Set&lt;string&gt;, topicNames: Set&lt;string&gt;): ReportEntry[]
       - Empty Set = show all (no filter for that dimension)
       - AND across dimensions, OR within
       - Returns entries matching: (any selected client OR all if empty) AND (any selected employee OR all if empty) AND (any selected topic OR all if empty)

    2. aggregateByClient(entries: ReportEntry[]): AggregationResult[]
       - Groups by clientId, returns { id: clientId, name: clientName, totalHours, revenue }
       - totalHours: sum of all entry hours (INCLUDING written-off)
       - revenue: sum of non-null entry revenues (entries with revenue: null contribute 0 to sum; if ALL entries have null revenue, result revenue is null)
       - Sorted by totalHours descending

    3. aggregateByEmployee(entries: ReportEntry[]): AggregationResult[]
       - Groups by userId, returns { id: userId, name: userName, totalHours, revenue }
       - Same revenue and hours rules as aggregateByClient
       - Sorted by totalHours descending

    4. aggregateByTopic(entries: ReportEntry[]): AggregationResult[]
       - Groups by topicName, returns { id: topicName, name: topicName, totalHours, revenue }
       - id equals name (topicName is the natural key -- no separate topic ID on ReportEntry)
       - Same revenue and hours rules as aggregateByClient
       - Sorted by totalHours descending

    AggregationResult type: { id: string, name: string, totalHours: number, revenue: number | null }

    Revenue aggregation logic (same for all three):
    - If at least one entry in the group has non-null revenue: sum the non-null values (null entries contribute 0)
    - If ALL entries in the group have null revenue: result revenue is null
    - This means: admin sees revenue numbers, non-admin sees null (since all their entries have null revenue)
    - Written-off entries have null revenue (from Plan 08-01), so they naturally get excluded from revenue sums

    Test cases for filterEntries:
    - Empty sets -> all entries returned
    - Single client selected -> only that client's entries
    - Multiple clients -> entries from any selected client
    - Client + employee filter -> intersection (AND)
    - Topic filter -> entries matching any selected topic
    - No matching entries -> empty array

    Test cases for each aggregation function:
    - Single group -> one result
    - Multiple groups -> sorted by totalHours descending
    - Written-off entries -> included in hours, excluded from revenue
    - All null revenue -> result revenue is null
    - Mix of null and non-null revenue -> sum only non-null
    - Empty input -> empty array
  </behavior>
  <implementation>
    1. RED: Create report-detail-utils.test.ts with test suites for all four functions.
       Create test helper to build ReportEntry objects (simpler than the mock factory in route.test.ts -- just needs the ReportEntry interface fields).
       Write tests covering all cases listed above.
       Create empty report-detail-utils.ts that exports stub functions (returning empty arrays) so imports resolve.
       Run tests -- they must FAIL.

    2. GREEN: Implement all four functions in report-detail-utils.ts.
       Export the AggregationResult interface from report-detail-utils.ts.
       filterEntries: check each dimension's set size, filter with AND logic.
       Each aggregate function: use Map for grouping, handle revenue null logic, sort by totalHours descending, return Array.from(map.values()).
       Run tests -- they must PASS.

    3. REFACTOR: Extract shared aggregation logic into a private helper if the three aggregate functions share significant code. The grouping key and name extraction differ, but the revenue summation and sorting logic is identical. Consider a generic helper:
       function aggregateBy(entries: ReportEntry[], keyFn: (e: ReportEntry) => string, nameFn: (e: ReportEntry) => string): AggregationResult[]
       Run tests again -- must still PASS.
  </implementation>
</feature>

<verification>
- `cd app && npm run test -- report-detail-utils --run` -- all new tests pass
- `cd app && npm run test -- --run` -- full suite passes (zero regressions)
- TypeScript compiles: `cd app && npx tsc --noEmit`
</verification>

<success_criteria>
- filterEntries correctly implements AND-across-dimensions, OR-within, empty-set-means-all
- aggregateByClient groups by clientId with correct hours and revenue
- aggregateByEmployee groups by userId with correct hours and revenue
- aggregateByTopic groups by topicName with correct hours and revenue
- Written-off entries included in hours, excluded from revenue
- All results sorted by totalHours descending
- Full test coverage for all edge cases
- AggregationResult type exported for downstream consumers
</success_criteria>

<output>
After completion, create `.planning/phases/08-data-layer-foundation/08-02-SUMMARY.md`
</output>
