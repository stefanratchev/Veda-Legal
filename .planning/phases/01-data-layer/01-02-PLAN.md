---
phase: 01-data-layer
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - app/src/app/(authenticated)/(admin)/reports/page.tsx
  - app/src/components/reports/ReportsContent.tsx
autonomous: true
requirements:
  - DAT-01
  - DAT-02
  - DAT-03

must_haves:
  truths:
    - "Server-rendered page returns identical response shape to the API route (topics, revenue, clientType, isWrittenOff, topicName, billableHours, totalWrittenOffHours)"
    - "ReportsContent TypeScript interfaces match the new API response shape"
    - "Initial page load (SSR) returns the same data as a subsequent client-side API fetch"
  artifacts:
    - path: "app/src/app/(authenticated)/(admin)/reports/page.tsx"
      provides: "Server component getReportData() with topic, revenue, and write-off logic matching route.ts"
      contains: "topicName"
    - path: "app/src/components/reports/ReportsContent.tsx"
      provides: "Updated TypeScript interfaces for the new response shape"
      contains: "TopicAggregation"
  key_links:
    - from: "app/src/app/(authenticated)/(admin)/reports/page.tsx"
      to: "app/src/components/reports/ReportsContent.tsx"
      via: "ReportData type import and prop passing"
      pattern: "ReportData"
    - from: "app/src/app/(authenticated)/(admin)/reports/page.tsx"
      to: "app/src/app/api/reports/route.ts"
      via: "Identical aggregation logic (must stay in sync)"
      pattern: "topicName.*Uncategorized"
---

<objective>
Update the server component and frontend TypeScript interfaces to match the extended API route from Plan 01.

Purpose: The reports page has two code paths — the API route (for client-side date changes) and the server component (for initial SSR page load). Both must return identical shapes. This plan brings the server component and frontend interfaces in sync with the API route changes.

Output: Updated `page.tsx` with matching aggregation logic and `ReportsContent.tsx` with updated TypeScript interfaces.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-layer/01-CONTEXT.md
@.planning/phases/01-data-layer/01-01-SUMMARY.md
@app/src/app/api/reports/route.ts
@app/src/app/(authenticated)/(admin)/reports/page.tsx
@app/src/components/reports/ReportsContent.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update server component getReportData() to match API route</name>
  <files>app/src/app/(authenticated)/(admin)/reports/page.tsx</files>
  <action>
Mirror the changes from Plan 01's route.ts into page.tsx's `getReportData()` function. The two code paths must produce identical response shapes.

**1. Update the Drizzle query** to select additional fields:
- Add `topicName: true` and `isWrittenOff: true` to the `timeEntries` columns (they may be implicitly selected since `columns` is not specified on `timeEntries` — check and add explicitly if needed)
- Add `clientType: true` to the `client` relation columns

**2. Extend the aggregation Maps** with the same tracking structures as route.ts:
- Employee map: add `topicMap`, `billableHours`, revenue accumulator per client
- Client map: add `clientType`, `topicMap`
- Summary level: add `totalWrittenOffHours` counter

**3. Update the aggregation loop** with identical logic to route.ts:
```
const topicName = entry.topicName || "Uncategorized";
const isWrittenOff = entry.isWrittenOff ?? false;
const clientType = entry.client.clientType;
const isBillable = clientType === "REGULAR";
const clientRate = entry.client.hourlyRate ? Number(entry.client.hourlyRate) : 0;
```

- Written-off hours: add to totalWrittenOffHours counter when isWrittenOff
- Revenue: only count when `!isWrittenOff && isBillable && clientRate > 0`
- Topic tracking: per-client and per-employee topicMaps
- Employee billableHours: `isBillable && !isWrittenOff`
- Employee revenue: per-client tracking of non-written-off REGULAR hours * rate

**4. Update response building** to include all new fields:
- `byClient`: add `clientType`, `topics[]`, revenue as number (0 for non-billable)
- `byEmployee`: add `topics[]`, `billableHours`, `revenue` (for admin, null for non-admin)
- `summary`: add `totalWrittenOffHours` (for admin, null for non-admin)
- `entries`: add `topicName`, `isWrittenOff`, `clientType`

**5. Fix existing revenue calculation** (same breaking change as route.ts):
- Revenue is always a number (0 for null rate, 0 for INTERNAL/MANAGEMENT)
- For non-admin: null out revenue, hourlyRate, billableHours as before

**6. Update the `ReportData` type import** — this comes from ReportsContent.tsx. Since Task 2 updates that type, and both files are in the same plan, coordinate: the interface updates in ReportsContent.tsx (Task 2) must happen first or simultaneously. The implementation approach is: update ReportsContent.tsx interfaces first (Task 2), then this file will type-check.

Actually, since we can't control execution order within a plan, structure the code so it works with the updated interfaces. Reference the `ReportData` import from `@/components/reports/ReportsContent`.

**Important:** Keep the code structure parallel to route.ts. Do not attempt to extract a shared utility — this is a known duplication that's acceptable for now (per research OPEN QUESTION #1 recommendation: "update both in parallel" for Phase 1).
  </action>
  <verify>
    <automated>cd /Users/stefan/projects/veda-legal-timesheets/app && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>TypeScript compiles without errors. The getReportData function returns the same shape as the API route.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Server component getReportData() produces identical response shape to the API route: topics[] on byClient/byEmployee, revenue as number, billableHours on byEmployee, topicName/isWrittenOff/clientType on entries, totalWrittenOffHours on summary. Non-admin null-out applied consistently.</done>
</task>

<task type="auto">
  <name>Task 2: Update ReportsContent TypeScript interfaces</name>
  <files>app/src/components/reports/ReportsContent.tsx</files>
  <action>
Update the TypeScript interfaces in ReportsContent.tsx to match the new API response shape. Only interfaces change — no behavioral changes to the component.

**1. Add `TopicAggregation` interface** (before EmployeeStats):
```typescript
interface TopicAggregation {
  topicName: string;
  totalHours: number;
  writtenOffHours: number;
}
```

**2. Update `EmployeeStats` interface:**
Add:
- `billableHours: number | null;` (null for non-admin)
- `revenue: number | null;` (null for non-admin)
- `topics: TopicAggregation[];`

**3. Update `ClientStats` interface:**
Add:
- `clientType: "REGULAR" | "INTERNAL" | "MANAGEMENT";`
- `topics: TopicAggregation[];`
Change:
- `revenue: number | null;` stays as-is (null for non-admin) — but note that for admin users, revenue is now always a number (never null for admin)

**4. Update `ReportData.summary` interface:**
Add:
- `totalWrittenOffHours: number | null;` (null for non-admin)

**5. Update `ReportData.entries` item type:**
Add:
- `topicName: string;`
- `isWrittenOff: boolean;`
- `clientType: "REGULAR" | "INTERNAL" | "MANAGEMENT";`

**Important:** Do NOT change any component logic, JSX rendering, or data handling. The existing component code should continue to work because:
- New fields are additive (old fields still exist)
- TypeScript interfaces are only more complete, not breaking
- UI components that consume these types will be updated in later phases

**Important:** The `Entry` interface (used internally in ReportsContent, lines ~38-51) appears to be a different shape from the entries in `ReportData`. It has `client: { id, name }` and `employee: { id, name }` instead of flat fields. Check if this interface is actually used anywhere in the component. If it's dead code, leave it as-is. If it's used, it may need updating too — but only if it maps from the API response entries.
  </action>
  <verify>
    <automated>cd /Users/stefan/projects/veda-legal-timesheets/app && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>TypeScript compiles. Interfaces match the new API response shape. No runtime behavioral changes.</manual>
    <sampling_rate>run after this task commits</sampling_rate>
  </verify>
  <done>ReportsContent.tsx TypeScript interfaces updated: TopicAggregation type added, EmployeeStats has revenue/billableHours/topics, ClientStats has clientType/topics, summary has totalWrittenOffHours, entries have topicName/isWrittenOff/clientType. No component behavioral changes — these are additive type updates for downstream UI phases.</done>
</task>

</tasks>

<verification>
1. `cd /Users/stefan/projects/veda-legal-timesheets/app && npx tsc --noEmit` — TypeScript compiles without errors
2. `cd /Users/stefan/projects/veda-legal-timesheets/app && npx vitest run --run` — full test suite passes (no regressions)
3. Manual: compare `page.tsx` getReportData return shape with `route.ts` response shape — they must be identical field-for-field
</verification>

<success_criteria>
- TypeScript compiles without errors across the project
- Full test suite passes (no regressions from interface changes)
- page.tsx getReportData() returns identical shape to route.ts GET handler
- ReportsContent.tsx interfaces include all new fields from the API extension
- Non-admin null-out is applied consistently in page.tsx (matching route.ts behavior)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-layer/01-02-SUMMARY.md`
</output>
