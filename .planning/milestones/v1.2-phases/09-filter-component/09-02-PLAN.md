---
phase: 09-filter-component
plan: 02
type: tdd
wave: 2
depends_on:
  - 09-01
files_modified:
  - app/src/components/reports/FilterBar.tsx
  - app/src/components/reports/FilterBar.test.tsx
autonomous: true
requirements:
  - FILT-04
  - FILT-05

must_haves:
  truths:
    - "User sees a horizontal row of three filter dropdowns: Clients, Employees, Topics"
    - "User can clear an individual filter by deselecting all options in that dropdown"
    - "User can clear all filters at once via a 'Clear all' link"
    - "'Clear all' link only appears when at least one filter is active"
    - "FilterBar exposes a single onChange callback with the complete filter state"
  artifacts:
    - path: "app/src/components/reports/FilterBar.tsx"
      provides: "Composed filter bar with three MultiSelectFilter instances"
      exports: ["FilterBar", "FilterState"]
      min_lines: 40
    - path: "app/src/components/reports/FilterBar.test.tsx"
      provides: "Integration tests for FilterBar"
      min_lines: 60
  key_links:
    - from: "app/src/components/reports/FilterBar.tsx"
      to: "app/src/components/ui/MultiSelectFilter.tsx"
      via: "import and 3 instances"
      pattern: "MultiSelectFilter"
    - from: "app/src/components/reports/FilterBar.tsx"
      to: "parent component (Detail tab)"
      via: "controlled props: filters FilterState, onChange callback"
      pattern: "onChange.*FilterState"
---

<objective>
Build and test the FilterBar wrapper component using TDD. FilterBar composes three MultiSelectFilter instances (Clients, Employees, Topics) in a horizontal row with a "Clear all" link. This is the composed unit that Phase 10 will integrate into the Detail tab.

Purpose: FILT-04 requires individual and global filter clearing. FILT-05 requires the "Clear all" visibility as a global active indicator. FilterBar manages these composed behaviors.

Output: Fully tested `FilterBar` component in `components/reports/`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-filter-component/09-CONTEXT.md
@.planning/phases/09-filter-component/09-RESEARCH.md
@.planning/phases/09-filter-component/09-01-SUMMARY.md
@app/src/components/ui/MultiSelectFilter.tsx
</context>

<feature>
  <name>FilterBar Wrapper Component</name>
  <files>app/src/components/reports/FilterBar.tsx, app/src/components/reports/FilterBar.test.tsx</files>
  <behavior>
    FilterBar is a controlled wrapper that renders three MultiSelectFilter instances in a horizontal row with a "Clear all" link.

    Exported types and component:
    ```typescript
    export interface FilterState {
      clientIds: Set&lt;string&gt;;
      employeeIds: Set&lt;string&gt;;
      topicNames: Set&lt;string&gt;;
    }

    interface FilterBarProps {
      clients: { id: string; label: string }[];
      employees: { id: string; label: string }[];
      topics: { id: string; label: string }[];
      filters: FilterState;
      onChange: (filters: FilterState) => void;
    }
    ```

    **Layout:**
    - Horizontal `flex` row with `gap-3` and `items-center`
    - Three MultiSelectFilter instances in order: Clients, Employees, Topics
    - "Clear all" link at the right end (pushed right with `ml-auto` or at end of flex)

    **"Clear all" link behavior:**
    - Only visible when `hasActiveFilters` is true (any of the three Sets has size > 0)
    - Clicking it calls `onChange` with all three Sets as `new Set()` (empty)
    - Styled as coral pink text link: `text-[var(--accent-pink)]`
    - Use ternary for conditional rendering: `hasActiveFilters ? <button.../> : null`

    **Individual filter change:**
    - When a single MultiSelectFilter calls its onChange, FilterBar constructs a new FilterState with the updated Set for that dimension and the other two unchanged, then calls its own `onChange(newFilterState)`

    **Prop threading:**
    - `clients` -> Clients MultiSelectFilter `options`
    - `employees` -> Employees MultiSelectFilter `options`
    - `topics` -> Topics MultiSelectFilter `options`
    - `filters.clientIds` -> Clients MultiSelectFilter `selected`
    - `filters.employeeIds` -> Employees MultiSelectFilter `selected`
    - `filters.topicNames` -> Topics MultiSelectFilter `selected`

    Test cases (RED phase):
    - Renders three MultiSelectFilter triggers with labels "Clients", "Employees", "Topics"
    - Does not show "Clear all" when no filters are active
    - Shows "Clear all" when at least one filter is active (any Set has items)
    - Clicking "Clear all" calls onChange with all three Sets empty
    - Changing a single filter (e.g., selecting a client) calls onChange with updated clientIds and unchanged employeeIds/topicNames
    - FilterBar passes correct options to each MultiSelectFilter instance
  </behavior>
  <implementation>
    This is a thin wrapper component. Keep it simple:

    1. Compute `hasActiveFilters` from `filters.clientIds.size + filters.employeeIds.size + filters.topicNames.size > 0`
    2. Create three handler functions (one per dimension) that construct new FilterState objects
    3. Render three MultiSelectFilter instances with labels "Clients", "Employees", "Topics"
    4. Conditionally render "Clear all" button

    Follow codebase conventions:
    - `"use client"` directive at top
    - Export `FilterState` interface for use in Phase 10
    - Use `useCallback` for handler functions to avoid unnecessary re-renders of MultiSelectFilter instances
    - Functional setState is not needed here since FilterBar is controlled (parent owns state)
    - `data-testid="filter-bar"` on the root div

    Test approach:
    - Mock MultiSelectFilter to simplify integration testing. Use `vi.mock` to render a simplified version that exposes the label and calls onChange when clicked.
    - Alternative: Do NOT mock MultiSelectFilter. Test the real composed behavior by clicking trigger buttons, selecting options, and verifying onChange calls. This is more robust since MultiSelectFilter is already tested in 09-01.
    - **Recommended:** Do NOT mock MultiSelectFilter. Use real component integration. This tests the actual wiring. The tests from 09-01 cover internal behavior; 09-02 tests the composition.
    - Use `fireEvent.click` to open dropdowns and select options
    - Verify `onChange` is called with correct `FilterState` structure
    - Verify "Clear all" appears/disappears based on active filter state
  </implementation>
</feature>

<verification>
```bash
cd app && npm run test -- FilterBar --run
```
All tests pass. No regressions:
```bash
cd app && npm run test -- --run
```
</verification>

<success_criteria>
- FilterBar renders three MultiSelectFilter instances with labels "Clients", "Employees", "Topics"
- "Clear all" link appears only when at least one filter has selections
- Clicking "Clear all" resets all three Sets to empty via onChange
- Changing a single filter calls onChange with correct updated FilterState
- FilterBar exports FilterState type for Phase 10 consumption
- All tests pass including existing suite (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/09-filter-component/09-02-SUMMARY.md`
</output>
